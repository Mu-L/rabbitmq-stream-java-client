= RabbitMQ Stream Java Client
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../../main/java]
:source-highlighter: prettify
:test-examples: ../../test/java/com/rabbitmq/stream/docs

The RabbitMQ Stream Java Client is a Java library to communicate with
the https://github.com/rabbitmq/rabbitmq-stream[RabbitMQ Stream Plugin].
It allows to create and delete streams, as well as to publish to and consume from
these streams.

== What is a RabbitMQ Stream?

A RabbitMQ stream is an append-only, FIFO structure. It differs from the classical
RabbitMQ queue in the way message consumption works. In a classical RabbitMQ queue,
consuming removes messages from the queue. In a RabbitMQ stream, consuming leaves
the stream intact. So the content of a stream can read and re-read without
impact or destructive effect.

None of the stream or classical queue data structure is better than the other,
they are usually suited for different use cases.

== When to Use RabbitMQ Stream?

A stream abstraction is useful when one or several consumer applications
require the whole history of data ("replay").

Streams can also be useful when a higher throughput than with classical
RabbitMQ queues is required. RabbitMQ streams use various optimization techniques
and a custom network protocol to achieve performances that are not possible
with the other protocols supported in RabbitMQ (AMQP, STOMP, MQTT). This
does not make the stream protocol better than these protocols, they just
all serve different purposes.

== Other Way to Use Streams in RabbitMQ

It is also possible to use the stream abstraction in RabbitMQ
with the AMQP 0-9-1 protocol. Instead of consuming from a stream
with the stream protocol, one consumes from a _stream queue_ with
the AMQP 0-9-1. A _stream queue_ is a special type of queue that
has been adapted to provide the stream semantics (mainly non-destructive
reading).

Using a stream queue has the advantage to provide the features
inherent to the stream abstraction (append-only structure, non-destructive
reading) with any AMQP 0-9-1 client library. This is clearly
interesting when considering the maturity of AMQP 0-9-1 client libraries
and the ecosystem around AMQP 0-9-1.

But by using a stream queue, one does not benefit from the performance
of the stream protocol, which has been designed for performance in mind,
whereas AMQP 0-9-1 is a more general-purpose protocol.

It is not possible to use stream queues with the stream Java client,
you need to use an AMQP 0-9-1 client library.

== Guarantees

RabbitMQ stream provides at-least-once guarantees thanks to the
publisher confirm mechanism, which is supported by the stream Java client.

== Using the Stream Java Client

The library requires Java 8 or more.

A RabbitMQ node with the stream plugin enabled is required:

* Download the https://bintray.com/rabbitmq/all-dev/rabbitmq-stream[latest generic Unix alpha from Bintray].
* Follow the https://www.rabbitmq.com/install-generic-unix.html[instructions to install the generic Unix package].
* Enable the plugin `./rabbitmq-plugins enable rabbitmq_stream`.
* Start the broker `./rabbitmq-server -detached`. This starts the stream listener on port 5555.

=== Dependencies

Use your favorite build management tool to add the client dependencies to your project.

Note the client uses the https://github.com/apache/qpid-proton-j[Apache QPid Proton-J]
library for AMQP 1.0 message encoding and decoding.

==== Maven

.pom.xml
[source,xml,subs="attributes,specialcharacters"]
----
<dependencies>

  <dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>stream-client</artifactId>
    <version>{project-version}</version>
  </dependency>

  <dependency>
    <groupId>org.apache.qpid</groupId>
    <artifactId>proton-j</artifactId>
    <version>{protonj-version}</version>
  </dependency>

</dependencies>

<repositories>

  <repository>
    <id>ossrh</id>
    <url>https://oss.sonatype.org/content/repositories/snapshots</url>
    <snapshots><enabled>true</enabled></snapshots>
    <releases><enabled>false</enabled></releases>
  </repository>

</repositories>
----

==== Gradle

.build.gradle
[source,groovy,subs="attributes,specialcharacters"]
----
dependencies {
  compile "com.rabbitmq:stream-client:{project-version}"
  compile "org.apache.qpid:proton-j:{protonj-version}"
}

repositories {
  maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
  mavenCentral()
}
----

=== Connecting to RabbitMQ Stream

The main API of the stream Java client is the `com.rabbitmq.stream.Client`
class. To connect to a local instance of the RabbitMQ Stream plugin
with the default user and password, just create an `Client` instance

[source,java,indent=0]
--------
include::{test-examples}/ClientUsage.java[tag=client-creation]
--------
<1> Connect to localhost:5555 with guest / guest

A `Client` constructor can take a `ClientParameters` to set
parameters like host, port, username, and password:

[source,java,indent=0]
--------
include::{test-examples}/ClientUsage.java[tag=client-creation-with-client-parameters]
--------
<1> Use `ClientParameters` to set connection parameters

=== Managing Streams

Streams can be created with the `Client#create(String)` method:

[source,java,indent=0]
--------
include::{test-examples}/ClientUsage.java[tag=stream-creation]
--------
<1> Create the `my-stream` stream
<2> Check if creation is OK
<3> Check response code

The `Constants` class can help to make sense of response codes.

The deletion of a stream follows the same pattern with the
`Client#delete(String)` method:

[source,java,indent=0]
--------
include::{test-examples}/ClientUsage.java[tag=stream-deletion]
--------
<1> Delete the `my-stream` stream
<2> Check if deletion is OK
<3> Check response code

Note you should avoid stream churn (creating and deleting streams
repetitively) as their creation and deletion imply
some significant housekeeping on the server side (interactions
with the file system, communication between nodes of the cluster).
Therefore you should consider streams as long-lived objects.

=== Publishing Messages



=== Consuming Messages