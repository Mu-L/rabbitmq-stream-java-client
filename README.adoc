:project-version: 0.1.0-SNAPSHOT
:protonj-version: 0.33.4

= RabbitMQ Stream Java Client

== Project Maturity

The project is in early stages of development and is considered experimental.
It is not ready for production use. Features and API are subject to change.

== Support

* For questions: https://groups.google.com/forum/#!forum/rabbitmq-users[RabbitMQ Users]
* For bugs and feature requests: https://github.com/reactor/reactor-rabbitmq/issues[GitHub Issues]

The project is currently under development, there is no guarantee yet that it will be maintained and supported
in the future (read: you are welcome to experiment with it and give feedback, but please do not base
your whole business on it).

== How to Use

=== Pre-requisites

The library requires Java 8 or more.

A RabbitMQ node with the stream plugin enabled is required:

 * Download the https://bintray.com/rabbitmq/all-dev/rabbitmq-stream[latest generic Unix alpha from Bintray].
 * Follow the https://www.rabbitmq.com/install-generic-unix.html[instructions to install the generic Unix package].
 * Enable the plugin `./rabbitmq-plugins enable rabbitmq_stream`.
 * Start the broker `./rabbitmq-server -detached`. This starts the stream listener on port 5555.

=== Dependencies

Use your favorite build management tool to add the client dependencies to your project.

==== Maven

.pom.xml
[source,xml,subs="attributes,specialcharacters"]
----
<dependencies>

  <dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>stream-client</artifactId>
    <version>{project-version}</version>
  </dependency>

  <dependency>
    <groupId>org.apache.qpid</groupId>
    <artifactId>proton-j</artifactId>
    <version>{protonj-version}</version>
  </dependency>

</dependencies>

<repositories>

  <repository>
    <id>ossrh</id>
    <url>https://oss.sonatype.org/content/repositories/snapshots</url>
    <snapshots><enabled>true</enabled></snapshots>
    <releases><enabled>false</enabled></releases>
  </repository>

</repositories>
----

==== Gradle

.build.gradle
[source,groovy,subs="attributes,specialcharacters"]
----
dependencies {
  compile "com.rabbitmq:stream-client:{project-version}"
  compile "org.apache.qpid:proton-j:{protonj-version}"
}

repositories {
  maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
  mavenCentral()
}
----

=== Sample Application

The next snippet shows a client instance used to publish messages. The body
of each message is made of the value of a sequence. A count down latch
is used to make sure all the messages have been confirmed before closing
the publisher connection.

[source,java]
----
import com.rabbitmq.stream.Client;

import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.IntStream;

...

int messageCount = 10000;
String stream = UUID.randomUUID().toString();
CountDownLatch confirmLatch = new CountDownLatch(messageCount);
Client publisher = new Client(new Client.ClientParameters()
  .confirmListener(publishingId -> confirmLatch.countDown()));              // <1>
publisher.create(stream);                                                   // <2>
IntStream.range(0, messageCount)
  .forEach(i -> publisher.publish(stream, String.valueOf(i).getBytes()));   // <3>
confirmLatch.await(10, TimeUnit.SECONDS);                                   // <4>
publisher.close();                                                          // <5>
----
<1> Count down on message publishing confirmation
<2> Create the target stream
<3> Publish a message in a loop
<4> Wait for all publishing confirmations to have arrived
<5> Close the publisher connection

The next snippet shows how to consume and process the messages published previously.
It sets up a chunk listener when creating the client instance. The chunk listener is called
every time a chunk (batch) of messages is delivered by the server to the client. It
asks the server to deliver another chunk with the `credit` command. A record listener
is also set up on client creation. The record listener is called every time a message
is delivered (as part of a chunk). Once all messages have been received, the sum is output
to the console, the stream is deleted, and the consumer connection is closed.

[source,java]
----
AtomicLong sum = new AtomicLong(0);
CountDownLatch consumeLatch = new CountDownLatch(messageCount);
Client consumer = new Client(new Client.ClientParameters()
  .chunkListener((client, subscriptionId, offset, recordCount, dataSize) ->
      client.credit(subscriptionId, 1))                                      // <1>
  .recordListener((subscriptionId, offset, message) -> {
    sum.addAndGet(Long.parseLong(new String(message.getBodyAsBinary())));    // <2>
    consumeLatch.countDown();                                                // <3>
}));

consumer.subscribe(1, stream, 0, 10);                                        // <4>
consumeLatch.await(10, TimeUnit.SECONDS);                                    // <5>

System.out.println("Sum: " + sum.get());                                     // <6>

consumer.delete(stream);                                                     // <7>
consumer.close();                                                            // <8>
----
<1> Ask for a new chunk for each chunk received
<2> Add the value in the message body to the sum
<3> Count down on each message
<4> Start consuming at the beginning of the stream
<5> Wait for all messages to have arrived
<6> Output the sum
<7> Delete the stream
<8> Close the consumer connection

== Build Instructions

You need JDK 1.8 or more installed.

To build the JAR file:

----
./mvnw clean package -DskipITs -DskipTests
----

To launch the test suite (requires a local RabbitMQ node with stream plugin enabled):

----
./mvnw verify
----

== Performance Tool

The project contains also a performance tool to test the RabbitMQ Stream plugin.
It is https://bintray.com/rabbitmq/java-tools-dev/stream-perf-test[downloadable from Bintray]
as an uber JAR and can be built separately as well.

=== Using the Performance Tool

To launch a run:

----
java -jar stream-perf-test-{version}.jar
----

The previous command will start publishing to and consuming from a stream created
only for the test.

To see the options:

----
java -jar stream-perf-test-{version}.jar --help
----

=== Building the Performance Tool

To build the uber JAR:

----
./mvnw clean package -Dmaven.test.skip -P performance-tool
----

Then run the tool:

----
java -jar target/stream-perf-test.jar
----

== Copyright and License

(c) 2020, VMware Inc or its affiliates.

Double licensed under the ASL2 and MPL1.1. See link:LICENSE[LICENSE] for details.
